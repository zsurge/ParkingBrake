C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE RUN
OBJECT MODULE PLACED IN ..\HEX\run.obj
COMPILER INVOKED BY: c:\Keil\C51\BIN\C51.EXE ..\SCR\run.c BROWSE INCDIR(..\INC) DEBUG OBJECTEXTEND PRINT(.\run.lst) TABS
                    -(2) OBJECT(..\HEX\run.obj)

line level    source

   1          /****************************************************************************
   2          * File:     RUN.c                           *
   3          * Created:    2015-02-13                          *
   4          * Last Change:                                *
   5          * Author:   chen zhi peng                         *
   6          * Description:  ³ÌÐòÔËÐÐÖ¸Ê¾ & º¯ÊýµÄ¼ÆÊ±                 *
   7          ****************************************************************************/
   8          #include "RUN.h"
   9          
  10          
  11          u8 xdata iTask;     //µ±Ç°Ö´ÐÐµÄÈÎÎñ
  12          u8 xdata iTask2;    //µ±Ç°Ö´ÐÐµÄÈÎÎñ
  13          u8 xdata ViceDo;    //¸±»úÖ´ÐÐÈÎÎñ
  14          u8 xdata ViceRal;   //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  15          u8 xdata ViceRal2;    //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  16          u8 xdata ViceSta;   //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  17          u8 data  ComNum;    //Ö÷¸±»úÍ¨ÐÅ¼ÆÊ±
  18          u8 xdata UpCt;      //Ì§Õ¢¼ÆÊý
  19          u8  data UpCtNum;     //Ì§Õ¢¼ÆÊý·À¶¶
  20          u8  data UpDcNum;     //Ì§Õ¢¼ÆÊý³¬Ê±¼õÊý
  21          
  22          
  23          
  24          u8 code iTask_buf[7][18]=   //ÈÎÎñ±í
  25          {/*  ÎÞÊÂ¼þ  ÊÖ¶¯ÂäÕ¢ ÄÚ²¿ÂäÕ¢ Í¨ÐÅÂäÕ¢ µØ¸ÐÂäÕ¢ µ½Ë®Æ½Î» Ç¿ÖÆÌ§¸Ë Ç¿Ì§¸´Î» µØ¸ÐÌ§Õ¢ ·ÀÔÒÌ§Õ¢ Óö×èÌ§Õ¢ ÄÚ²
             -¿Ì§Õ¢ Í¨ÐÅÌ§Õ¢ ÊÓÆµÌ§Õ¢ ÊÖ¶¯Ì§Õ¢ µ½´¹Ö±Î» ¹ßÐÔµô¸Ë µô¸Ë¸´Î»        ÊÂ¼þ *///
  26            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA,  /* ×´Ì¬Î´³õÊ¼»¯ */
  27            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_DW, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_UP, TASK_NA, TASK_UP, TASK_US, TASK_UP, TASK_NA,  /* ³õÊ¼Î´Öª×´Ì¬ */
  28            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_US, TASK_NA, TASK_US,  /* ÕýÔÚÌ§Õ¢×´Ì¬ */
  29            TASK_NA, TASK_DW, TASK_DW, TASK_DW, TASK_DW, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA,  /* ´¹Ö±×´Ì¬ */
  30            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_DS, TASK_UP, TASK_UP, TASK_UP, TASK_U
             -P, TASK_UP, TASK_UP, TASK_UP, TASK_NA, TASK_NA, TASK_NA,  /* ÕýÔÚÂäÕ¢×´Ì¬ */
  31            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_U
             -P, TASK_UP, TASK_UP, TASK_UP, TASK_NA, TASK_NA, TASK_NA,  /* Ë®Æ½×´Ì¬ */
  32            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_US, TASK_NA, TASK_NA,  /* ´íÎó×´Ì¬ */
  33          };
  34          
  35          
  36          
  37          void intMcu() 
  38          {  
  39   1        EA=0;     //½ûÖ¹È«¾ÖÖÐ¶Ï
  40   1        
  41   1        SCON=0x50;  //´®ÐÐ½Ó¿Ú¹¤×÷ÓÚÄ£Ê½1£¬ÔÊÐí½ÓÊÕÊý¾ÝSM0 SM1 SM2 REN TB8 RB8 TI RI
  42   1        TMOD=0x21;  //¼ÆÊ±Æ÷1¹¤×÷ÓÚÄ£Ê½2 | GATE C/T M1 M0 | GATE C/T M1 M0 |
  43   1                 //¼ÆÊ±Æ÷0¹¤×÷ÓÚÄ£Ê½1 | Timer1    |    Timer0    |a
  44   1      //´®¿Ú²ÎÊýÅäÖÃ
  45   1      //  TH1=0xF4;   /*Éè¶¨²¨ÌØÂÊÎª2400, ¾§Õñ11.0592MHz*/
  46   1      //  TH1=0xE8;   /*Éè¶¨²¨ÌØÂÊÎª2400, ¾§Õñ22.1184MHz*/
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 2   

  47   1      //  TH1=0xFD;   /*Éè¶¨²¨ÌØÂÊÎª9600£¬¾§Õñ11.0592MHz*/
  48   1      //  TH1=0xFA;   /*Éè¶¨²¨ÌØÂÊÎª9600£¬¾§Õñ22.1184MHz*/
  49   1        TH1=0xFD;   /*Éè¶¨²¨ÌØÂÊÎª19200£¬¾§Õñ22.1184MHz*/
  50   1        TR1=1;    //Æô¶¯¼ÆÊ±Æ÷1¿ªÊ¼¼ÆÊý 
  51   1        ES=1;     //ÔÊÐí´®¿ÚÖÐ¶Ï
  52   1      //¶¨Ê±Æ÷0ÅäÖÃ
  53   1        TL0 = 0xCD;   //ÉèÖÃ¶¨Ê±³õÖµ
  54   1        TH0 = 0xF8;   //ÉèÖÃ¶¨Ê±³õÖµ
  55   1        TR0=1;    //Æô¶¯¶¨Ê±Æ÷0
  56   1        ET0=1;      //ÔÊÐíT0ÖÐ¶Ï
  57   1      //ÖÐ¶Ï0ÅäÖÃ 
  58   1      //  IT0=1;    //Íâ²¿ÖÐ¶Ï0µçÆ½Ìø±ä²úÉúÖÐ¶Ï
  59   1        EX0=0;      //½ûÖ¹Íâ²¿ÖÐ¶Ï0
  60   1      //ÖÐ¶Ï1ÅäÖÃ 
  61   1      //  IT1=1;      //Íâ²¿ÖÐ¶Ï1µçÆ½Ìø±ä²úÉúÖÐ¶Ï
  62   1        EX1=0;    //½ûÖ¹Íâ²¿ÖÐ¶Ï1
  63   1      //ÓÅÏÈ¼¶ÅäÖÃ
  64   1        PS=1;     //Éè¶¨´®¿ÚÖÐ¶ÏÓÅÏÈ
  65   1      //ÖÐ¶Ï×Ü¿ª¹ØÅäÖÃ
  66   1        EA=1;
  67   1      }
  68          
  69          
  70          //¶¨Ê±Æ÷2³õÊ¼»¯
  71          #if TIMER2
  72          void Timer2_Init(void)
  73          {
  74   1        T2MOD = 0;    //³õÊ¼»¯Ä£Ê½¼Ä´æÆ÷
  75   1        T2CON = 0;    //³õÊ¼»¯¿ØÖÆ¼Ä´æÆ÷
  76   1        TL2 = (65536 - 50000) / 256;    //ÉèÖÃ¶¨Ê±³õÖµ 50000--50ms 9216---10ms
  77   1        TH2 = (65536 - 50000) % 256;    //ÉèÖÃ¶¨Ê±³õÖµ
  78   1        TR2 = 1;    //¶¨Ê±Æ÷2¿ªÊ¼¼ÆÊ±
  79   1      
  80   1      
  81   1        //  TH2 = (65536-9216)/256;
  82   1        //  TL2 = (65536-9216)%256;
  83   1        EA=1;                      //´ò¿ª×ÜÖÐ¶Ï
  84   1        ET2=1;                     //´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï  
  85   1        TR2=1;                     //´ò¿ª¶¨Ê±Æ÷¿ª¹Ø
  86   1      }
  87          #endif
  88          
  89          
  90          
  91          
  92          void intRun() { iTask= ITASK_INT; iTask2= ITASK_NA; ViceDo= 0; ViceRal= 0; ViceRal2= 0; ViceSta= 0; UpCt=0
             -; UpCtNum=0; }
  93          
  94          void delay(u8 cnt)  //   ÑÓÊ±µ¥Î»:
  95          {
  96   1       u16 i;
  97   1       i=cnt*200; 
  98   1       while (--i);
  99   1      }
 100          
 101          
 102          void ComClk() 
 103            { 
 104   1          if(ComNum) ComNum--;
 105   1          if(COM1.RX_TimeOut) COM1.RX_TimeOut--;
 106   1        }
 107          
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 3   

 108          void UpCtClk() { if(UpCtNum) UpCtNum--; }
 109          void UpDcClk() { if(UpDcNum) UpDcNum--; }
 110          
 111          void sysint()
 112          {
 113   1        intMcu(); 
 114   1        intUsart();
 115   1        #if TIMER2
 116   1        Timer2_Init();
 117   1        #endif
 118   1        intRun();
 119   1        intBuzz();
 120   1        intErr();
 121   1        intInput();
 122   1        intclk();
 123   1        intMotor();
 124   1        intOut(); 
 125   1        intAtRun();
 126   1        RomTest();
 127   1      }
 128          
 129          
 130          
 131          void iTaskCtr()
 132          {
 133   1      
 134   1        if(iTask < Even)
 135   1          {
 136   2            iTask2= iTask_buf[mPosD][Even];   //¸ù¾ÝÊÂ¼þºÍ×´Ì¬²é±í£¬»ñÈ¡ÈÎÎñ
 137   2            
 138   2            if(iTask2!= MTASK_NA) 
 139   2              {
 140   3                mTask= iTask2;
 141   3                iTask= Even;
 142   3                if(!JY) if(iTask== ITASK_DG_UP || iTask== ITASK_DRAG_UP)  UpCt++;
 143   3              }
 144   2          }
 145   1      }
 146          
 147          
 148          void ViceCtr()
 149          {
 150   1        if(McuId== MACHI_VICE)
 151   1          {
 152   2            switch(ViceRal)
 153   2              {
 154   3                case POS_HOR:
 155   3                case POS_DW:
 156   3                  Event(ITASK_COM_DW);
 157   3                  speak(VICE_STA,mPosD2);
 158   3                  break;
 159   3                case POS_UP:
 160   3                case POS_VER:
 161   3                  HDwSta=STA_NA; HDwNum=HDW_ON_TIME;
 162   3                  DgSta=STA_NA; DgNum=DG_OFF_TIME;
 163   3                  Event(ITASK_COM_UP);
 164   3                  speak(VICE_STA,mPosD2);
 165   3                  break;
 166   3                case POS_INT:
 167   3                  speak(VICE_STA,mPosD2);
 168   3                  break;
 169   3                default: break;
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 4   

 170   3              }
 171   2            ViceRal=0;
 172   2          }
 173   1        if(McuId== MACHI_MASTER)
 174   1          { 
 175   2            if(iTask== ITASK_INT || iTask== ITASK_STR) return;
 176   2            if(!ComNum) ComNum= COM_TIME;
 177   2            else return;
 178   2            switch(mPosD2)
 179   2              {
 180   3                case POS_HOR:
 181   3                case POS_DW:
 182   3                  switch(ViceRal)
 183   3                    {
 184   4                      case POS_HOR:
 185   4                        ViceSta=0;
 186   4                        speak(VICE_STA,POS_INT);
 187   4                        break;
 188   4                      case POS_DW:
 189   4                        if(!ViceSta) ViceSta=VICE_STA_EN;
 190   4                        if(ViceSta==VICE_STA_DGON)        speak(VICE_STA,POS_UP);
 191   4                        else                  speak(VICE_STA,POS_INT);
 192   4                        break;
 193   4                      case POS_VER:
 194   4                        if(!ViceSta) ViceSta=VICE_STA_EN; 
 195   4                        if(mPosD2==POS_DW)            speak(VICE_STA,POS_DW);
 196   4                        if(ViceSta==VICE_STA_DW)        speak(VICE_STA,POS_DW);
 197   4                        else if(ViceSta==VICE_STA_DGOF)     { speak(VICE_STA,POS_DW); ViceSta=0; }
 198   4                        else                  speak(VICE_STA,POS_INT);
 199   4                        break;
 200   4                      case POS_UP:
 201   4                        if(ViceSta!=VICE_STA_DGON)        DgStaClr();
 202   4                        if(!ViceSta)              ViceSta=VICE_STA_EN;
 203   4                        if(mPosD2==POS_DW)            Event(ITASK_COM_UP);
 204   4                        else if(ViceSta==VICE_STA_DGOF)     speak(VICE_STA,POS_DW);
 205   4                        else                  speak(VICE_STA,POS_INT);
 206   4                        break;
 207   4                      default: 
 208   4                        speak(VICE_STA,POS_INT);
 209   4                        break;
 210   4                    }
 211   3                  ViceRal=0;
 212   3                  break;
 213   3                case POS_VER:
 214   3                case POS_UP:
 215   3                  speak(VICE_STA,mPosD2);
 216   3                  break;
 217   3                default: 
 218   3                  speak(VICE_STA,mPosD2);
 219   3                  break;
 220   3              }
 221   2          }
 222   1        
 223   1      
 224   1        //***********************·¢ËÍ×´Ì¬´¦Àí***********************//
 225   1        
 226   1      }
 227          
 228          void iTaskControl()     //Íâ²¿ÈÎÎñ´¦Àí
 229          {
 230   1      
 231   1        ViceCtr();    //¸±»ú¿ØÖÆ
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 5   

 232   1        switch(iTask) //µ±Ç°Ö´ÐÐÈÎÎñ
 233   1          {
 234   2            case ITASK_INT:
 235   2              BmRed();    //²¦Âë²ÎÊý¶ÁÈ¡
 236   2              if(!HUP && !HDW && !HOR) AtNum= 30;
 237   2              else AtNum= 6;
 238   2              iTask=ITASK_STR;
 239   2              break;
 240   2      
 241   2            case ITASK_STR:
 242   2              if(!HUP && !HDW && !HOR && !AtNum) { aLine= 1;iTask= ITASK_NA; }
 243   2              else if(!AtNum) { iTask=ITASK_NA; }
 244   2              break;
 245   2      
 246   2            case ITASK_REACH_H:
 247   2            case ITASK_REACH_V:
 248   2            case ITASK_INER_OK:
 249   2            case ITASK_COER_OK:
 250   2              iTask=ITASK_NA;
 251   2              break;
 252   2              
 253   2      
 254   2            case ITASK_NA:
 255   2            case ITASK_COER_UP:
 256   2            case ITASK_INER_DW:
 257   2              iTaskCtr();
 258   2              break;
 259   2              
 260   2            case ITASK_DG_UP:
 261   2            case ITASK_DRAG_UP:
 262   2            case ITASK_FZ_UP:
 263   2            case ITASK_AUTO_UP:
 264   2            case ITASK_COM_UP:
 265   2            case ITASK_VDO_UP:
 266   2            case ITASK_HAN_UP:
 267   2              iTaskCtr();
 268   2              break;
 269   2              
 270   2            case ITASK_HAN_DW:
 271   2            case ITASK_COM_DW:
 272   2            case ITASK_AUTO_DW:
 273   2            case ITASK_DG_DW:
 274   2              iTaskCtr();
 275   2              break;
 276   2      
 277   2              
 278   2            default: iTask=ITASK_NA; break;   //µç»úÏà¹Ø±äÁ¿³õÊ¼»¯
 279   2          }
 280   1      }
 281          
 282          void t0_interrupt(void)  interrupt 1 //using 1
 283          {
 284   1        TF0= 0;
 285   1        TL0 = 0xCD;   //ÉèÖÃ¶¨Ê±³õÖµ
 286   1        TH0 = 0xF8;   //ÉèÖÃ¶¨Ê±³õÖµ
 287   1      
 288   1      
 289   1        T1Ms_clk();
 290   1        mCtrClk();
 291   1        ComClk();
 292   1      //  LED=!LED;
 293   1      }
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 6   

 294          
 295          
 296          
 297          
 298          //  ÂäÕ¢Ê±·ÖÎª5¸ö½×¶Î£¬·Ö±ðÊÇ
 299          //  1.Æð²½½×¶Î£¬´¹Ö±Î»µ½Æð²½Î»
 300          //  2.ÔËÐÐ½×¶Î£¬Æð²½Î»µ½ÖÐ¶Î
 301          //  3.¼õËÙ½×¶Î£¬ÖÐ¶Îµ½»º³åÎ»
 302          //  4.»º³å½×¶Î£¬»º³åµ½Æ½ÎÈÎ»
 303          //  5.ÎÈ¶¨½×¶Î£¬Æ½ÎÈÎ»µ½Ë®Æ½Î»
 304          //  ´ó¸ÅË¼Â·ÊÇ£¬¸ù¾Ý²âÊÔµÄÊý¾Ý£¬µÃ³öÆð²½½×¶ÎºÍÔËÐÐ½×¶ÎµÄËùÐèÒªµÄ×ªÊýÇø¼ä
 305          //  È»ºó´ÓÕâ¸öÇø¼ä¿ªÊ¼ÅÐ¶¨£¬¸ù¾Ý½øÈë¶¨Ê±Æ÷µÄ´ÎÊý£¬µÃµ½ÐÂµÄ×ªÊý£¬ÒÔ¼°×ÜµÄÊ±¼ä
 306          //  Õâ¸öÊ±¼äÔÙ¸ù¾Ý¾­ÑéÖµ£¬ÅÐ¶¨ÊÇ²»ÊÇ³¬³öÎÒÃÇÔ¤ÆÚµÄ×ªÊýÇø¼ä£¬ÈôÊÇ£¬ÔòÌ§Õ¢
 307          
 308          //Ô¤ÆÚµÄÂäÕ¢Ê±¼äÎª5Ãë£¬¿ìÓÚ5Ãë£¬ÈÏÎª¾ÍÓÐ·çÏÕ
 309          
 310          #if 0 
              void testTimer2(void)
              { 
                //Ê×ÏÈÅÐ¶ÏÊÇ·ñµ½ÁË¼õËÙ½×¶Î
                //30ÊÇ¼ÙÉèµ½¼õËÙ½×¶Î²âËÙ»·µÄ×ªÊý£¬Êµ¼ÊÐèÒªÈ¥ÊÖ¶¯µÄ¼ÆÁ¿
                if(SpeRinN >= 30) //ÒÑµ½¼õËÙ½×¶Î£¬Ö®ºóÒª¸ù¾Ý²âËÙ»·µÄÈ¦ÊýºÍÊ±¼äÅÐ¶¨ÊÇ·ñÊ§ËÙ
                {
                  if(gRepairMotor.CurrentCounts == 0)
                  {
                    gRepairMotor.InitSpeRin = SpeRinN;//¼ÇÂ¼¿ªÊ¼¼ÆËãÇ°²âËÙ»·µÄÈ¦Êý
                  }
                  
                  gRepairMotor.CurrentCounts++;//½øÈëÖÐ¶ÏµÄ´ÎÊý£¬¸ù¾ÝÖÐ¶ÏµÄ´ÎÊýÅÐ¶¨ËùÓÃµÄÊ±¼ä
                  
                  //ÒòÎªÊÇ10msµÄ¶¨Ê±Æ÷£¬3.8µÄµç»úÃ¿¸öÖÜÆÚÊÇ22.5ms£¬ËùÓÐ½øÐÐÅÐ¶¨Ã¿50msÓÐÁ½´Î
                  //ÕâÀï²âÊÔÊ¹ÓÃ£¬ÏÈ¹Ì¶¨3.8µç»ú£¬releaseÊ±»áÊ¹ÓÃºê¶¨Òå£¬¶¨Òå²»Í¬µÄ¼ÆËã·½Ê½ºÍÅÐ¶¨Ìõ¼þ
                  if((gRepairMotor.CurrentCounts != 0) && (gRepairMotor.CurrentCounts % 5 == 0))
                  {
                    if (gRepairMotor.FlagValue >= 4)
                    {
                      Event(ITASK_DG_UP);//Î£ÏÕ£¬Ì§¸Ë
                    }
                    
                    if(gRepairMotor.LastSpeRin !=0)
                    {
                      //ÕâÀï¸ù¾ÝÊÇ¿ª5Uµç»úºÍ3Uµç»úÅÐ¶¨£¬¿ÕÔØ×î¿ì8È¦£¬ËùÒÔÈ¡6È¦×öÎªÅÐ¶¨Ìõ¼þ
                      if((SpeRinN - gRepairMotor.LastSpeRin) >= 4  /*&&ÕâÀïÓ¦¸Ã¸ù¾ÝµçÑ¹*/)
                      {
                        //Õâ¸öÊ±ºò¾Í±È½ÏÎ£ÏÕÁË
                        gRepairMotor.FlagValue++;
                      }
                    }
              
                    gRepairMotor.LastSpeRin = SpeRinN;
                    
                    //´òÓ¡µ±Ç°²âËÙ»·Öµ
                    Uart_Print(3,gRepairMotor.Direction);     
              
                  }
                }
                
              }
              
              //¶¨Ê±Æ÷ÖÐ¶Ï2
              void Timer2_ISR(void) interrupt 5 //¶¨Ê±Æ÷2ÖÐ¶Ï
              {
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 7   

                TF2=0;
                EXF2 = 0;
                TL2 = (65536 - 9216) / 256;   //ÉèÖÃ¶¨Ê±³õÖµ
                TH2 = (65536 - 9216) % 256;   //ÉèÖÃ¶¨Ê±³õÖµ
              
                testTimer2();  
              }
              #endif 
 364          
 365          #if 1 
 366          #define TIMER_FRE  90 
 367          #define BASIC_SPEED_100MS 8 //Ã¿100ms²âËÙ»·×ªµ½µÄÈ¦Êý
 368          #define SPRING_PARAM_OFFSET 2//µ¯»É²ÎÊý
 369          #define STANDARD_VALUE 72//µ¯»É±ê×¼Öµ
 370          
 371          
 372          void motorTimer2(void)
 373          { 
 374   1      # if 1
 375   1          //Ã¿¸ô100ºÁÃë½øÀ´ÅÐ¶¨Ò»´Î
 376   1        if(SpeRinN >= 1) //²âËÙ»·×ª¶¯²Å¿ªÊ¼½øÀ´
 377   1        {   
 378   2            //´ÓµÚ900ºÁÃëµÄÊ±ºò½øÀ´£¬È»ºóÃ¿100ºÁÃëÅÐ¶¨Ò»´Î
 379   2            if(gRepairMotor.CurrentCounts++ >= TIMER_FRE);//½øÈëÖÐ¶ÏµÄ´ÎÊý£¬¸ù¾ÝÖÐ¶ÏµÄ´ÎÊýÅÐ¶¨ËùÓÃµÄÊ±¼ä
 380   2              {      
 381   3              //ÕâÀï²âÊÔÊ¹ÓÃ£¬ÏÈ¹Ì¶¨3.8µç»ú£¬releaseÊ±»áÊ¹ÓÃºê¶¨Òå£¬¶¨Òå²»Í¬µÄ¼ÆËã·½Ê½ºÍÅÐ¶¨Ìõ¼þ
 382   3              
 383   3              if(gRepairMotor.CurrentCounts % TIMER_FRE == 0)
 384   3              {
 385   4                      //ÏÈÅÐ¶¨Ì§Õ¢
 386   4                      if(gRepairMotor.Direction == POS_UP)
 387   4                      {
 388   5                          if(gRepairMotor.CurrentCounts == TIMER_FRE)
 389   5                          {
 390   6                              if (SpeRinN > STANDARD_VALUE + SPRING_PARAM_OFFSET)
 391   6                              {
 392   7                                  //Èý¸ùµ¯»É
 393   7                                  gCurrentSpringNum = 3;
 394   7                              }
 395   6                              else if(SpeRinN < STANDARD_VALUE + SPRING_PARAM_OFFSET && SpeRinN >= STANDARD_VALU
             -E -SPRING_PARAM_OFFSET)
 396   6                              {
 397   7                                  //Á½¸ùµ¯»É£¬ÐèÒª±¨¾¯
 398   7                                  gCurrentSpringNum = 2;
 399   7                              }
 400   6                              else
 401   6                              {
 402   7                                  //Ö»ÓÐÒ»¸ùµ¯»É
 403   7                                  gCurrentSpringNum = 1;
 404   7                              }
 405   6                          }
 406   5                      }
 407   4                      else //ÂäÕ¢
 408   4                      {
 409   5                          if(gCurrentSpringNum == 1 || SpeRinN >= STANDARD_VALUE + SPRING_PARAM_OFFSET*2-1)
 410   5                          {
 411   6                              //Ö´ÐÐÌ§Õ¢
 412   6                              Event(ITASK_DG_UP);
 413   6                          }
 414   5                      
 415   5                      }
 416   4                      
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 8   

 417   4                //´òÓ¡µ±Ç°²âËÙ»·Öµ
 418   4                Uart_Print(3,gRepairMotor.Direction);   
 419   4                    }
 420   3      
 421   3          }
 422   2        }
 423   1      #else 
                g_timer_run_counter++;
                if(g_timer_run_counter % TIMER_FRE == 0)
                {
                  if(SpeRinN > FISTER_SPRING_BREAK && SpeRinN <= SECOND_SPRING_BREAK && g_timer_run_counter == 1)
                  {
                    g_timer_run_counter = 0;
                    Event(ITASK_DG_UP);//Î£ÏÕ£¬Ì§¸Ë
                  }
                  else if(SpeRinN > SECOND_SPRING_BREAK && SpeRinN <= THIRD_SPRING_BREAK && g_timer_run_counter == 2)
                  {
                    g_timer_run_counter = 0;
                    Event(ITASK_DG_UP);//Î£ÏÕ£¬Ì§¸Ë
                  }
                  else if(SpeRinN > THIRD_SPRING_BREAK && SpeRinN <= FORTH_SPRING_BREAK  && g_timer_run_counter == 3)
                  {
                    g_timer_run_counter = 0;
                    Event(ITASK_DG_UP);//Î£ÏÕ£¬Ì§¸Ë
                  }
                  else
                  {
                    g_timer_run_counter = 0;
                  }
              
                  //´òÓ¡µ±Ç°²âËÙ»·Öµ
                  Uart_Print(3,gRepairMotor.Direction);
                }
              
                #endif
 452   1      }
 453          
 454          //¶¨Ê±Æ÷ÖÐ¶Ï2
 455          void Timer2_ISR(void) interrupt 5 //¶¨Ê±Æ÷2ÖÐ¶Ï
 456          {
 457   1        TF2=0;
 458   1        EXF2 = 0;
 459   1        TL2 = (65536 - 9216) / 256;   //ÉèÖÃ¶¨Ê±³õÖµ
 460   1        TH2 = (65536 - 9216) % 256;   //ÉèÖÃ¶¨Ê±³õÖµ
 461   1      
 462   1        motorTimer2();  
 463   1      }
 464          
 465          //void Timer2_Zero(void)
 466          //{ 
 467          //  TF2=0;
 468          //  EXF2 = 0; 
 469          //}
 470          
 471          #endif
 472          
 473          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    977    ----
   CONSTANT SIZE    =    126    ----
C51 COMPILER V9.00   RUN                                                                   03/11/2019 18:50:53 PAGE 9   

   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
