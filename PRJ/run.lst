C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE RUN
OBJECT MODULE PLACED IN ..\HEX\run.obj
COMPILER INVOKED BY: c:\Keil\C51\BIN\C51.EXE ..\SCR\run.c BROWSE INCDIR(..\INC) DEBUG OBJECTEXTEND PRINT(.\run.lst) TABS
                    -(2) OBJECT(..\HEX\run.obj)

line level    source

   1          /****************************************************************************
   2          * File:     RUN.c                           *
   3          * Created:    2015-02-13                          *
   4          * Last Change:                                *
   5          * Author:   chen zhi peng                         *
   6          * Description:  ³ÌÐòÔËÐÐÖ¸Ê¾ & º¯ÊýµÄ¼ÆÊ±                 *
   7          ****************************************************************************/
   8          #include "RUN.h"
   9          
  10          
  11          u8 xdata iTask;     //µ±Ç°Ö´ÐÐµÄÈÎÎñ
  12          u8 xdata iTask2;    //µ±Ç°Ö´ÐÐµÄÈÎÎñ
  13          u8 xdata ViceDo;    //¸±»úÖ´ÐÐÈÎÎñ
  14          u8 xdata ViceRal;   //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  15          u8 xdata ViceRal2;    //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  16          u8 xdata ViceSta;   //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  17          u8 data  ComNum;    //Ö÷¸±»úÍ¨ÐÅ¼ÆÊ±
  18          u8 xdata UpCt;      //Ì§Õ¢¼ÆÊý
  19          u8  data UpCtNum;     //Ì§Õ¢¼ÆÊý·À¶¶
  20          u8  data UpDcNum;     //Ì§Õ¢¼ÆÊý³¬Ê±¼õÊý
  21          
  22          
  23          
  24          
  25          u8 code iTask_buf[7][18]=   //ÈÎÎñ±í
  26          {/*  ÎÞÊÂ¼þ  ÊÖ¶¯ÂäÕ¢ ÄÚ²¿ÂäÕ¢ Í¨ÐÅÂäÕ¢ µØ¸ÐÂäÕ¢ µ½Ë®Æ½Î» Ç¿ÖÆÌ§¸Ë Ç¿Ì§¸´Î» µØ¸ÐÌ§Õ¢ ·ÀÔÒÌ§Õ¢ Óö×èÌ§Õ¢ ÄÚ²
             -¿Ì§Õ¢ Í¨ÐÅÌ§Õ¢ ÊÓÆµÌ§Õ¢ ÊÖ¶¯Ì§Õ¢ µ½´¹Ö±Î» ¹ßÐÔµô¸Ë µô¸Ë¸´Î»        ÊÂ¼þ *///
  27            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA,  /* ×´Ì¬Î´³õÊ¼»¯ */
  28            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_DW, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_UP, TASK_NA, TASK_UP, TASK_US, TASK_UP, TASK_NA,  /* ³õÊ¼Î´Öª×´Ì¬ */
  29            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_US, TASK_NA, TASK_US,  /* ÕýÔÚÌ§Õ¢×´Ì¬ */
  30            TASK_NA, TASK_DW, TASK_DW, TASK_DW, TASK_DW, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA,  /* ´¹Ö±×´Ì¬ */
  31            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_DS, TASK_UP, TASK_UP, TASK_UP, TASK_U
             -P, TASK_UP, TASK_UP, TASK_UP, TASK_NA, TASK_NA, TASK_NA,  /* ÕýÔÚÂäÕ¢×´Ì¬ */
  32            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_U
             -P, TASK_UP, TASK_UP, TASK_UP, TASK_NA, TASK_NA, TASK_NA,  /* Ë®Æ½×´Ì¬ */
  33            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_US, TASK_NA, TASK_NA,  /* ´íÎó×´Ì¬ */
  34          };
  35          
  36          
  37          
  38          void intMcu() 
  39          {  
  40   1        EA=0;     //½ûÖ¹È«¾ÖÖÐ¶Ï
  41   1        
  42   1        SCON=0x50;  //´®ÐÐ½Ó¿Ú¹¤×÷ÓÚÄ£Ê½1£¬ÔÊÐí½ÓÊÕÊý¾ÝSM0 SM1 SM2 REN TB8 RB8 TI RI
  43   1        TMOD=0x21;  //¼ÆÊ±Æ÷1¹¤×÷ÓÚÄ£Ê½2 | GATE C/T M1 M0 | GATE C/T M1 M0 |
  44   1                 //¼ÆÊ±Æ÷0¹¤×÷ÓÚÄ£Ê½1 | Timer1    |    Timer0    |a
  45   1      //´®¿Ú²ÎÊýÅäÖÃ
  46   1      //  TH1=0xF4;   /*Éè¶¨²¨ÌØÂÊÎª2400, ¾§Õñ11.0592MHz*/
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 2   

  47   1      //  TH1=0xE8;   /*Éè¶¨²¨ÌØÂÊÎª2400, ¾§Õñ22.1184MHz*/
  48   1      //  TH1=0xFD;   /*Éè¶¨²¨ÌØÂÊÎª9600£¬¾§Õñ11.0592MHz*/
  49   1      //  TH1=0xFA;   /*Éè¶¨²¨ÌØÂÊÎª9600£¬¾§Õñ22.1184MHz*/
  50   1        TH1=0xFD;   /*Éè¶¨²¨ÌØÂÊÎª19200£¬¾§Õñ22.1184MHz*/
  51   1        TR1=1;    //Æô¶¯¼ÆÊ±Æ÷1¿ªÊ¼¼ÆÊý 
  52   1        ES=1;     //ÔÊÐí´®¿ÚÖÐ¶Ï
  53   1      //¶¨Ê±Æ÷0ÅäÖÃ
  54   1        TL0 = 0xCD;   //ÉèÖÃ¶¨Ê±³õÖµ
  55   1        TH0 = 0xF8;   //ÉèÖÃ¶¨Ê±³õÖµ
  56   1        TR0=1;    //Æô¶¯¶¨Ê±Æ÷0
  57   1        ET0=1;      //ÔÊÐíT0ÖÐ¶Ï
  58   1      //ÖÐ¶Ï0ÅäÖÃ 
  59   1      //  IT0=1;    //Íâ²¿ÖÐ¶Ï0µçÆ½Ìø±ä²úÉúÖÐ¶Ï
  60   1        EX0=0;      //½ûÖ¹Íâ²¿ÖÐ¶Ï0
  61   1      //ÖÐ¶Ï1ÅäÖÃ 
  62   1      //  IT1=1;      //Íâ²¿ÖÐ¶Ï1µçÆ½Ìø±ä²úÉúÖÐ¶Ï
  63   1        EX1=0;    //½ûÖ¹Íâ²¿ÖÐ¶Ï1
  64   1      //ÓÅÏÈ¼¶ÅäÖÃ
  65   1        PS=1;     //Éè¶¨´®¿ÚÖÐ¶ÏÓÅÏÈ
  66   1      //ÖÐ¶Ï×Ü¿ª¹ØÅäÖÃ
  67   1        EA=1;
  68   1      }
  69          
  70          
  71          //¶¨Ê±Æ÷2³õÊ¼»¯
  72          #if TIMER2
              void Timer2_Init(void)
              {
                T2MOD = 0;    //³õÊ¼»¯Ä£Ê½¼Ä´æÆ÷
                T2CON = 0;    //³õÊ¼»¯¿ØÖÆ¼Ä´æÆ÷
                  TH2 = (65536 - 9216*5) / 256;   //ÉèÖÃ¶¨Ê±³õÖµ
                TL2 = (65536 - 9216*5) % 256;   //ÉèÖÃ¶¨Ê±³õÖµ 46080--50ms 9216---10ms
                
              
              
                //  TH2 = (65536-9216)/256;
                //  TL2 = (65536-9216)%256;
                EA=1;                      //´ò¿ª×ÜÖÐ¶Ï
                ET2=1;                     //´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï  
                  TR2 = 1;    //¶¨Ê±Æ÷2¿ªÊ¼¼ÆÊ±
              }
              #endif
  89          
  90          
  91          
  92          
  93          void intRun() { iTask= ITASK_INT; iTask2= ITASK_NA; ViceDo= 0; ViceRal= 0; ViceRal2= 0; ViceSta= 0; UpCt=0
             -; UpCtNum=0; }
  94          
  95          void delay(u8 cnt)  //   ÑÓÊ±µ¥Î»:
  96          {
  97   1       u16 i;
  98   1       i=cnt*200; 
  99   1       while (--i);
 100   1      }
 101          
 102          
 103          void ComClk() 
 104            { 
 105   1          if(ComNum) ComNum--;
 106   1          if(COM1.RX_TimeOut) COM1.RX_TimeOut--;
 107   1        }
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 3   

 108          
 109          void UpCtClk() { if(UpCtNum) UpCtNum--; }
 110          void UpDcClk() { if(UpDcNum) UpDcNum--; }
 111          
 112          void sysint()
 113          {
 114   1        intMcu(); 
 115   1        intUsart();
 116   1        #if TIMER2
                Timer2_Init();
                #endif
 119   1        intRun();
 120   1        intBuzz();
 121   1        intErr();
 122   1        intInput();
 123   1        intclk();
 124   1        intMotor();
 125   1        intOut(); 
 126   1        intAtRun();
 127   1        RomTest();
 128   1      }
 129          
 130          
 131          
 132          void iTaskCtr()
 133          {
 134   1      
 135   1        if(iTask < Even)
 136   1          {
 137   2            iTask2= iTask_buf[mPosD][Even];   //¸ù¾ÝÊÂ¼þºÍ×´Ì¬²é±í£¬»ñÈ¡ÈÎÎñ
 138   2            
 139   2            if(iTask2!= MTASK_NA) 
 140   2              {
 141   3                mTask= iTask2;
 142   3                iTask= Even;
 143   3                if(!JY) if(iTask== ITASK_DG_UP || iTask== ITASK_DRAG_UP)  UpCt++;
 144   3              }
 145   2          }
 146   1      }
 147          
 148          
 149          void ViceCtr()
 150          {
 151   1        if(McuId== MACHI_VICE)
 152   1          {
 153   2            switch(ViceRal)
 154   2              {
 155   3                case POS_HOR:
 156   3                case POS_DW:
 157   3                  Event(ITASK_COM_DW);
 158   3                  speak(VICE_STA,mPosD2);
 159   3                  break;
 160   3                case POS_UP:
 161   3                case POS_VER:
 162   3                  HDwSta=STA_NA; HDwNum=HDW_ON_TIME;
 163   3                  DgSta=STA_NA; DgNum=DG_OFF_TIME;
 164   3                  Event(ITASK_COM_UP);
 165   3                  speak(VICE_STA,mPosD2);
 166   3                  break;
 167   3                case POS_INT:
 168   3                  speak(VICE_STA,mPosD2);
 169   3                  break;
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 4   

 170   3                default: break;
 171   3              }
 172   2            ViceRal=0;
 173   2          }
 174   1        if(McuId== MACHI_MASTER)
 175   1          { 
 176   2            if(iTask== ITASK_INT || iTask== ITASK_STR) return;
 177   2            if(!ComNum) ComNum= COM_TIME;
 178   2            else return;
 179   2            switch(mPosD2)
 180   2              {
 181   3                case POS_HOR:
 182   3                case POS_DW:
 183   3                  switch(ViceRal)
 184   3                    {
 185   4                      case POS_HOR:
 186   4                        ViceSta=0;
 187   4                        speak(VICE_STA,POS_INT);
 188   4                        break;
 189   4                      case POS_DW:
 190   4                        if(!ViceSta) ViceSta=VICE_STA_EN;
 191   4                        if(ViceSta==VICE_STA_DGON)        speak(VICE_STA,POS_UP);
 192   4                        else                  speak(VICE_STA,POS_INT);
 193   4                        break;
 194   4                      case POS_VER:
 195   4                        if(!ViceSta) ViceSta=VICE_STA_EN; 
 196   4                        if(mPosD2==POS_DW)            speak(VICE_STA,POS_DW);
 197   4                        if(ViceSta==VICE_STA_DW)        speak(VICE_STA,POS_DW);
 198   4                        else if(ViceSta==VICE_STA_DGOF)     { speak(VICE_STA,POS_DW); ViceSta=0; }
 199   4                        else                  speak(VICE_STA,POS_INT);
 200   4                        break;
 201   4                      case POS_UP:
 202   4                        if(ViceSta!=VICE_STA_DGON)        DgStaClr();
 203   4                        if(!ViceSta)              ViceSta=VICE_STA_EN;
 204   4                        if(mPosD2==POS_DW)            Event(ITASK_COM_UP);
 205   4                        else if(ViceSta==VICE_STA_DGOF)     speak(VICE_STA,POS_DW);
 206   4                        else                  speak(VICE_STA,POS_INT);
 207   4                        break;
 208   4                      default: 
 209   4                        speak(VICE_STA,POS_INT);
 210   4                        break;
 211   4                    }
 212   3                  ViceRal=0;
 213   3                  break;
 214   3                case POS_VER:
 215   3                case POS_UP:
 216   3                  speak(VICE_STA,mPosD2);
 217   3                  break;
 218   3                default: 
 219   3                  speak(VICE_STA,mPosD2);
 220   3                  break;
 221   3              }
 222   2          }
 223   1        
 224   1      
 225   1        //***********************·¢ËÍ×´Ì¬´¦Àí***********************//
 226   1        
 227   1      }
 228          
 229          void iTaskControl()     //Íâ²¿ÈÎÎñ´¦Àí
 230          {
 231   1      
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 5   

 232   1        ViceCtr();    //¸±»ú¿ØÖÆ
 233   1        switch(iTask) //µ±Ç°Ö´ÐÐÈÎÎñ
 234   1          {
 235   2            case ITASK_INT:
 236   2              BmRed();    //²¦Âë²ÎÊý¶ÁÈ¡
 237   2              if(!HUP && !HDW && !HOR) AtNum= 30;
 238   2              else AtNum= 6;
 239   2              iTask=ITASK_STR;
 240   2              break;
 241   2      
 242   2            case ITASK_STR:
 243   2              if(!HUP && !HDW && !HOR && !AtNum) { aLine= 1;iTask= ITASK_NA; }
 244   2              else if(!AtNum) { iTask=ITASK_NA; }
 245   2              break;
 246   2      
 247   2            case ITASK_REACH_H:
 248   2            case ITASK_REACH_V:
 249   2            case ITASK_INER_OK:
 250   2            case ITASK_COER_OK:
 251   2              iTask=ITASK_NA;
 252   2              break;
 253   2              
 254   2      
 255   2            case ITASK_NA:
 256   2            case ITASK_COER_UP:
 257   2            case ITASK_INER_DW:
 258   2              iTaskCtr();
 259   2              break;
 260   2              
 261   2            case ITASK_DG_UP:
 262   2            case ITASK_DRAG_UP:
 263   2            case ITASK_FZ_UP:
 264   2            case ITASK_AUTO_UP:
 265   2            case ITASK_COM_UP:
 266   2            case ITASK_VDO_UP:
 267   2            case ITASK_HAN_UP:
 268   2              iTaskCtr();
 269   2              break;
 270   2              
 271   2            case ITASK_HAN_DW:
 272   2            case ITASK_COM_DW:
 273   2            case ITASK_AUTO_DW:
 274   2            case ITASK_DG_DW:
 275   2              iTaskCtr();
 276   2              break;
 277   2      
 278   2              
 279   2            default: iTask=ITASK_NA; break;   //µç»úÏà¹Ø±äÁ¿³õÊ¼»¯
 280   2          }
 281   1      }
 282          
 283          void t0_interrupt(void)  interrupt 1 //using 1
 284          {
 285   1        TF0= 0;
 286   1        TL0 = 0xCD;   //ÉèÖÃ¶¨Ê±³õÖµ
 287   1        TH0 = 0xF8;   //ÉèÖÃ¶¨Ê±³õÖµ
 288   1      
 289   1      
 290   1        T1Ms_clk();
 291   1        mCtrClk();
 292   1        ComClk();
 293   1      //  LED=!LED;
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 6   

 294   1      }
 295          
 296          
 297          
 298          #if 0 
              //  ÂäÕ¢Ê±·ÖÎª5¸ö½×¶Î£¬·Ö±ðÊÇ
              //  1.Æð²½½×¶Î£¬´¹Ö±Î»µ½Æð²½Î»
              //  2.ÔËÐÐ½×¶Î£¬Æð²½Î»µ½ÖÐ¶Î
              //  3.¼õËÙ½×¶Î£¬ÖÐ¶Îµ½»º³åÎ»
              //  4.»º³å½×¶Î£¬»º³åµ½Æ½ÎÈÎ»
              //  5.ÎÈ¶¨½×¶Î£¬Æ½ÎÈÎ»µ½Ë®Æ½Î»
              //  ´ó¸ÅË¼Â·ÊÇ£¬¸ù¾Ý²âÊÔµÄÊý¾Ý£¬µÃ³öÆð²½½×¶ÎºÍÔËÐÐ½×¶ÎµÄËùÐèÒªµÄ×ªÊýÇø¼ä
              //  È»ºó´ÓÕâ¸öÇø¼ä¿ªÊ¼ÅÐ¶¨£¬¸ù¾Ý½øÈë¶¨Ê±Æ÷µÄ´ÎÊý£¬µÃµ½ÐÂµÄ×ªÊý£¬ÒÔ¼°×ÜµÄÊ±¼ä
              //  Õâ¸öÊ±¼äÔÙ¸ù¾Ý¾­ÑéÖµ£¬ÅÐ¶¨ÊÇ²»ÊÇ³¬³öÎÒÃÇÔ¤ÆÚµÄ×ªÊýÇø¼ä£¬ÈôÊÇ£¬ÔòÌ§Õ¢
              
              //Ô¤ÆÚµÄÂäÕ¢Ê±¼äÎª5Ãë£¬¿ìÓÚ5Ãë£¬ÈÏÎª¾ÍÓÐ·çÏÕ
              
              
              void testTimer2(void)
              { 
                //Ê×ÏÈÅÐ¶ÏÊÇ·ñµ½ÁË¼õËÙ½×¶Î
                //30ÊÇ¼ÙÉèµ½¼õËÙ½×¶Î²âËÙ»·µÄ×ªÊý£¬Êµ¼ÊÐèÒªÈ¥ÊÖ¶¯µÄ¼ÆÁ¿
                if(SpeRinN >= 30) //ÒÑµ½¼õËÙ½×¶Î£¬Ö®ºóÒª¸ù¾Ý²âËÙ»·µÄÈ¦ÊýºÍÊ±¼äÅÐ¶¨ÊÇ·ñÊ§ËÙ
                {
                  if(gRepairMotor.CurrentCounts == 0)
                  {
                    gRepairMotor.InitSpeRin = SpeRinN;//¼ÇÂ¼¿ªÊ¼¼ÆËãÇ°²âËÙ»·µÄÈ¦Êý
                  }
                  
                  gRepairMotor.CurrentCounts++;//½øÈëÖÐ¶ÏµÄ´ÎÊý£¬¸ù¾ÝÖÐ¶ÏµÄ´ÎÊýÅÐ¶¨ËùÓÃµÄÊ±¼ä
                  
                  //ÒòÎªÊÇ10msµÄ¶¨Ê±Æ÷£¬3.8µÄµç»úÃ¿¸öÖÜÆÚÊÇ22.5ms£¬ËùÓÐ½øÐÐÅÐ¶¨Ã¿50msÓÐÁ½´Î
                  //ÕâÀï²âÊÔÊ¹ÓÃ£¬ÏÈ¹Ì¶¨3.8µç»ú£¬releaseÊ±»áÊ¹ÓÃºê¶¨Òå£¬¶¨Òå²»Í¬µÄ¼ÆËã·½Ê½ºÍÅÐ¶¨Ìõ¼þ
                  if((gRepairMotor.CurrentCounts != 0) && (gRepairMotor.CurrentCounts % 5 == 0))
                  {
                    if (gRepairMotor.FlagValue >= 4)
                    {
                      Event(ITASK_DG_UP);//Î£ÏÕ£¬Ì§¸Ë
                    }
                    
                    if(gRepairMotor.LastSpeRin !=0)
                    {
                      //ÕâÀï¸ù¾ÝÊÇ¿ª5Uµç»úºÍ3Uµç»úÅÐ¶¨£¬¿ÕÔØ×î¿ì8È¦£¬ËùÒÔÈ¡6È¦×öÎªÅÐ¶¨Ìõ¼þ
                      if((SpeRinN - gRepairMotor.LastSpeRin) >= 4  /*&&ÕâÀïÓ¦¸Ã¸ù¾ÝµçÑ¹*/)
                      {
                        //Õâ¸öÊ±ºò¾Í±È½ÏÎ£ÏÕÁË
                        gRepairMotor.FlagValue++;
                      }
                    }
              
                    gRepairMotor.LastSpeRin = SpeRinN;
                    
                    //´òÓ¡µ±Ç°²âËÙ»·Öµ
                    Uart_Print(3,gRepairMotor.Direction);     
              
                  }
                }
                
              }
              
              //¶¨Ê±Æ÷ÖÐ¶Ï2
              void Timer2_ISR(void) interrupt 5 //¶¨Ê±Æ÷2ÖÐ¶Ï
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 7   

              {
                TF2=0;
                EXF2 = 0;
                TL2 = (65536 - 9216) / 256;   //ÉèÖÃ¶¨Ê±³õÖµ
                TH2 = (65536 - 9216) % 256;   //ÉèÖÃ¶¨Ê±³õÖµ
              
                testTimer2();  
              }
              #endif 
 365          
 366          
 367          //#define TIMER_FRE  5         //¼ÆËãÖÜÆÚ
 368          //#define BASIC_OFFSET_250MS 4 //Ã¿250ms²âËÙ»·×ªµ½µÄÈ¦Êý
 369          //#define SPRING_PARAM_OFFSET1 2//µ¯»É²ÎÊý
 370          //#define SPRING_PARAM_OFFSET2 3//µ¯»É²ÎÊý
 371          //#define SPRING_PARAM_OFFSET3 4//µ¯»É²ÎÊý
 372          //#define BASIC_SPRING_NUM 46//µ¯»É±ê×¼Öµ
 373          
 374          //#define START_POSITION 50   //´ÓµÚ50´Î½øÈëÖÐ¶Ï¿ªÊ¼¼ÆËã
 375          //#define END_POSITION (START_POSITION+TIMER_FRE*SPRING_CHECK_NUM)  //´ÓµÚ50´Î½øÈëÖÐ¶Ï¿ªÊ¼¼ÆËã
 376          //#define TIMER_FRE  5        //¼ÆËãÖÜÆÚ
 377          //#define THREE_SPRING_LOWER_LIMIT 16 //Èç¹ûÍ³¼Æ×ÜµÄÈ¦Êý²î´óÓÚÕâ¸öÖµ£¬ËµÃ÷ÒÑ¾­²»ÊÇÈý¸ùµ¯»ÉÁË
 378          //#define TWO_SPRINT_LOWER_LIMIT 26 //Èç¹ûÍ³¼Æ×ÜµÄÈ¦Êý²î´óÓÚÕâ¸öÖµ£¬ËµÃ÷ÒÑ¾­²»ÊÇÁ½¸ùµ¯»ÉÁË
 379          //#define BASIC_SPRING_NUM 38//µ¯»É±ê×¼Öµ
 380          //#define BASIC_OFFSET_250MS 4 //Ã¿250ms²âËÙ»·×ªµ½µÄÈ¦Êý
 381          //#define SPRING_CHECK_NUM 6//È¡Ñù´ÎÊý
 382          
 383          #if TIMER2
              #define START_POSITION 50   //´ÓµÚ50´Î½øÈëÖÐ¶Ï¿ªÊ¼¼ÆËã
              #define END_POSITION (START_POSITION+TIMER_FRE*SPRING_CHECK_NUM)  //´ÓµÚ50´Î½øÈëÖÐ¶Ï¿ªÊ¼¼ÆËã
              #define TIMER_FRE  5        //¼ÆËãÖÜÆÚ
              #define THREE_SPRING_LOWER_LIMIT 18//16+2 //Èç¹ûÍ³¼Æ×ÜµÄÈ¦Êý²î´óÓÚÕâ¸öÖµ£¬ËµÃ÷ÒÑ¾­²»ÊÇÈý¸ùµ¯»ÉÁË
              #define TWO_SPRINT_LOWER_LIMIT 28//26+2 //Èç¹ûÍ³¼Æ×ÜµÄÈ¦Êý²î´óÓÚÕâ¸öÖµ£¬ËµÃ÷ÒÑ¾­²»ÊÇÁ½¸ùµ¯»ÉÁË
              #define BASIC_SPRING_NUM 40//38+2//µ¯»É±ê×¼Öµ
              #define BASIC_OFFSET_250MS 4 //Ã¿250ms²âËÙ»·×ªµ½µÄÈ¦Êý
              #define SPRING_CHECK_NUM 6//È¡Ñù´ÎÊý
              
              void motorTimer2(void)
              {
              //    gRepairMotor.CurrentCounts++ ;
              //    //´òÓ¡µ±Ç°²âËÙ»·Öµ
              //    Uart_Print(3,gRepairMotor.Direction);   
              
                  gRepairMotor.CurrentCounts++ ;
                  //´òÓ¡µ±Ç°²âËÙ»·Öµ
                  Uart_Print(3,gRepairMotor.Direction);  
              
              //    if(SpeRinN >= 1 && gRepairMotor.Direction == POS_DW) //²âËÙ»·×ª¶¯²Å¿ªÊ¼½øÀ´
              //    { 
              //        gRepairMotor.CurrentCounts++ ; 
              
              //        if((gRepairMotor.CurrentCounts >= START_POSITION) && (gRepairMotor.CurrentCounts % TIMER_FRE == 
             -0) && gRepairMotor.CurrentCounts <= END_POSITION)//38
              //        {
              //            gRepairMotor.Times++;
              //            
              //            if(SpeRinN >= BASIC_SPRING_NUM + BASIC_OFFSET_250MS*gRepairMotor.Times)
              //            {
              //                gRepairMotor.FlagValue ++;//ÕâÀïÓ¦¸Ã²»»á³öÏÖ£¬Èç¹û³öÏÖ¾ÍÊÇ´óÎÊÌâ
              //            }   
              
              //            gRepairMotor.LastSpeRin = SpeRinN;
C51 COMPILER V9.00   RUN                                                                   03/16/2019 17:13:31 PAGE 8   

              //            //¼ÆËãµ±Ç°¶à×ßÁË¶àÉÙÈ¦
              //            if(gRepairMotor.LastSpeRin > (BASIC_SPRING_NUM+BASIC_OFFSET_250MS*(gRepairMotor.Times-1)))
              //            {                
              //                gRepairMotor.AverageValue += gRepairMotor.LastSpeRin-(BASIC_SPRING_NUM+BASIC_OFFSET_250M
             -S*(gRepairMotor.Times-1));                
              //            }
              
              //            if(gRepairMotor.Times <= 4 && gRepairMotor.AverageValue >= BASIC_OFFSET_250MS*3)
              //            {
              //                Event(ITASK_DG_UP);
              //                err_volu(ERR_SPRI_ERR); 
              //            }
              // 
              //            if (gRepairMotor.FlagValue >= 4 || gRepairMotor.AverageValue >= TWO_SPRINT_LOWER_LIMIT) //²»
             -ÐèÍêÈ«×ßÍêÅÐ¶¨£¬¿ÉÒÔÖ±½ÓÈÏÎªÊÇÓÐÎÊÌâµÄ 
              //            //if (gRepairMotor.FlagValue >= 4 )
              //            {            
              //                Event(ITASK_DG_UP);
              //                err_volu(ERR_SPRI_ERR);
              //                
              //            }
              
              //            if(gRepairMotor.AverageValue >= THREE_SPRING_LOWER_LIMIT)
              //            {
              //                //±¨¾¯£¬Ö»ÓÐÁ½¸ùµ¯»É   
              //                err_volu(ERR_SPRI_LIT);
              //            }
              
              //            //´òÓ¡µ±Ç°²âËÙ»·Öµ
              //        Uart_Print(3,gRepairMotor.Direction);            
              //        }  
              //        
              //    }
              
              }
              
              //¶¨Ê±Æ÷ÖÐ¶Ï2
              void Timer2_ISR(void) interrupt 5 //¶¨Ê±Æ÷2ÖÐ¶Ï
              {
                TF2=0;
                EXF2 = 0;
                motorTimer2(); 
              }
              
              #endif
 460          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    768    ----
   CONSTANT SIZE    =    126    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
