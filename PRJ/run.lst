C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE RUN
OBJECT MODULE PLACED IN ..\HEX\run.obj
COMPILER INVOKED BY: c:\Keil\C51\BIN\C51.EXE ..\SCR\run.c BROWSE INCDIR(..\INC) DEBUG OBJECTEXTEND PRINT(.\run.lst) TABS
                    -(2) OBJECT(..\HEX\run.obj)

line level    source

   1          /****************************************************************************
   2          * File:     RUN.c                           *
   3          * Created:    2015-02-13                          *
   4          * Last Change:                                *
   5          * Author:   chen zhi peng                         *
   6          * Description:  ³ÌÐòÔËÐÐÖ¸Ê¾ & º¯ÊýµÄ¼ÆÊ±                 *
   7          ****************************************************************************/
   8          #include "RUN.h"
   9          
  10          
  11          u8 xdata iTask;     //µ±Ç°Ö´ÐÐµÄÈÎÎñ
  12          u8 xdata iTask2;    //µ±Ç°Ö´ÐÐµÄÈÎÎñ
  13          u8 xdata ViceDo;    //¸±»úÖ´ÐÐÈÎÎñ
  14          u8 xdata ViceRal;   //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  15          u8 xdata ViceRal2;    //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  16          u8 xdata ViceSta;   //¸±»úÊµ¼ÊÈÎÎñ×´Ì¬
  17          u8 data  ComNum;    //Ö÷¸±»úÍ¨ÐÅ¼ÆÊ±
  18          u8 xdata UpCt;      //Ì§Õ¢¼ÆÊý
  19          u8  data UpCtNum;     //Ì§Õ¢¼ÆÊý·À¶¶
  20          u8  data UpDcNum;     //Ì§Õ¢¼ÆÊý³¬Ê±¼õÊý
  21          
  22          
  23          
  24          
  25          u8 code iTask_buf[7][18]=   //ÈÎÎñ±í
  26          {/*  ÎÞÊÂ¼þ  ÊÖ¶¯ÂäÕ¢ ÄÚ²¿ÂäÕ¢ Í¨ÐÅÂäÕ¢ µØ¸ÐÂäÕ¢ µ½Ë®Æ½Î» Ç¿ÖÆÌ§¸Ë Ç¿Ì§¸´Î» µØ¸ÐÌ§Õ¢ ·ÀÔÒÌ§Õ¢ Óö×èÌ§Õ¢ ÄÚ²
             -¿Ì§Õ¢ Í¨ÐÅÌ§Õ¢ ÊÓÆµÌ§Õ¢ ÊÖ¶¯Ì§Õ¢ µ½´¹Ö±Î» ¹ßÐÔµô¸Ë µô¸Ë¸´Î»        ÊÂ¼þ *///
  27            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA,  /* ×´Ì¬Î´³õÊ¼»¯ */
  28            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_DW, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_UP, TASK_NA, TASK_UP, TASK_US, TASK_UP, TASK_NA,  /* ³õÊ¼Î´Öª×´Ì¬ */
  29            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_US, TASK_NA, TASK_US,  /* ÕýÔÚÌ§Õ¢×´Ì¬ */
  30            TASK_NA, TASK_DW, TASK_DW, TASK_DW, TASK_DW, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA,  /* ´¹Ö±×´Ì¬ */
  31            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_DS, TASK_UP, TASK_UP, TASK_UP, TASK_U
             -P, TASK_UP, TASK_UP, TASK_UP, TASK_NA, TASK_NA, TASK_NA,  /* ÕýÔÚÂäÕ¢×´Ì¬ */
  32            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_U
             -P, TASK_UP, TASK_UP, TASK_UP, TASK_NA, TASK_NA, TASK_NA,  /* Ë®Æ½×´Ì¬ */
  33            TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_DS, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_NA, TASK_N
             -A, TASK_NA, TASK_NA, TASK_NA, TASK_US, TASK_NA, TASK_NA,  /* ´íÎó×´Ì¬ */
  34          };
  35          
  36          
  37          
  38          void intMcu() 
  39          {  
  40   1        EA=0;     //½ûÖ¹È«¾ÖÖÐ¶Ï
  41   1        
  42   1        SCON=0x50;  //´®ÐÐ½Ó¿Ú¹¤×÷ÓÚÄ£Ê½1£¬ÔÊÐí½ÓÊÕÊý¾ÝSM0 SM1 SM2 REN TB8 RB8 TI RI
  43   1        TMOD=0x21;  //¼ÆÊ±Æ÷1¹¤×÷ÓÚÄ£Ê½2 | GATE C/T M1 M0 | GATE C/T M1 M0 |
  44   1                 //¼ÆÊ±Æ÷0¹¤×÷ÓÚÄ£Ê½1 | Timer1    |    Timer0    |a
  45   1      //´®¿Ú²ÎÊýÅäÖÃ
  46   1      //  TH1=0xF4;   /*Éè¶¨²¨ÌØÂÊÎª2400, ¾§Õñ11.0592MHz*/
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 2   

  47   1      //  TH1=0xE8;   /*Éè¶¨²¨ÌØÂÊÎª2400, ¾§Õñ22.1184MHz*/
  48   1      //  TH1=0xFD;   /*Éè¶¨²¨ÌØÂÊÎª9600£¬¾§Õñ11.0592MHz*/
  49   1      //  TH1=0xFA;   /*Éè¶¨²¨ÌØÂÊÎª9600£¬¾§Õñ22.1184MHz*/
  50   1        TH1=0xFD;   /*Éè¶¨²¨ÌØÂÊÎª19200£¬¾§Õñ22.1184MHz*/
  51   1        TR1=1;    //Æô¶¯¼ÆÊ±Æ÷1¿ªÊ¼¼ÆÊý 
  52   1        ES=1;     //ÔÊÐí´®¿ÚÖÐ¶Ï
  53   1      //¶¨Ê±Æ÷0ÅäÖÃ
  54   1        TL0 = 0xCD;   //ÉèÖÃ¶¨Ê±³õÖµ
  55   1        TH0 = 0xF8;   //ÉèÖÃ¶¨Ê±³õÖµ
  56   1        TR0=1;    //Æô¶¯¶¨Ê±Æ÷0
  57   1        ET0=1;      //ÔÊÐíT0ÖÐ¶Ï
  58   1      //ÖÐ¶Ï0ÅäÖÃ 
  59   1      //  IT0=1;    //Íâ²¿ÖÐ¶Ï0µçÆ½Ìø±ä²úÉúÖÐ¶Ï
  60   1        EX0=0;      //½ûÖ¹Íâ²¿ÖÐ¶Ï0
  61   1      //ÖÐ¶Ï1ÅäÖÃ 
  62   1      //  IT1=1;      //Íâ²¿ÖÐ¶Ï1µçÆ½Ìø±ä²úÉúÖÐ¶Ï
  63   1        EX1=0;    //½ûÖ¹Íâ²¿ÖÐ¶Ï1
  64   1      //ÓÅÏÈ¼¶ÅäÖÃ
  65   1        PS=1;     //Éè¶¨´®¿ÚÖÐ¶ÏÓÅÏÈ
  66   1      //ÖÐ¶Ï×Ü¿ª¹ØÅäÖÃ
  67   1        EA=1;
  68   1      }
  69          
  70          
  71          //¶¨Ê±Æ÷2³õÊ¼»¯
  72          #if TIMER2
              void Timer2_Init(void)
              {
                T2MOD = 0;    //³õÊ¼»¯Ä£Ê½¼Ä´æÆ÷
                T2CON = 0;    //³õÊ¼»¯¿ØÖÆ¼Ä´æÆ÷
                  TH2 = (65536 - 9216*5) / 256;   //ÉèÖÃ¶¨Ê±³õÖµ
                TL2 = (65536 - 9216*5) % 256;   //ÉèÖÃ¶¨Ê±³õÖµ 46080--50ms 9216---10ms
                
              
              
                //  TH2 = (65536-9216)/256;
                //  TL2 = (65536-9216)%256;
                EA=1;                      //´ò¿ª×ÜÖÐ¶Ï
                ET2=1;                     //´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï  
                  TR2 = 1;    //¶¨Ê±Æ÷2¿ªÊ¼¼ÆÊ±
              }
              #endif
  89          
  90          
  91          
  92          
  93          void intRun() { iTask= ITASK_INT; iTask2= ITASK_NA; ViceDo= 0; ViceRal= 0; ViceRal2= 0; ViceSta= 0; UpCt=0
             -; UpCtNum=0; }
  94          
  95          void delay(u8 cnt)  //   ÑÓÊ±µ¥Î»:
  96          {
  97   1       u16 i;
  98   1       i=cnt*200; 
  99   1       while (--i);
 100   1      }
 101          
 102          //void delay_ms(u8 ms)    
 103          //{  
 104          //    u16 i;  
 105          //    do{  
 106          //        i=MAIN_Fosc/9600;  
 107          //        while(--i);     //96T per loop  
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 3   

 108          //    }while(--ms);       //--ms  ms=ms-1  
 109          //}  
 110          
 111          
 112          
 113          
 114          void ComClk() 
 115            { 
 116   1          if(ComNum) ComNum--;
 117   1          if(COM1.RX_TimeOut) COM1.RX_TimeOut--;
 118   1        }
 119          
 120          void UpCtClk() { if(UpCtNum) UpCtNum--; }
 121          void UpDcClk() { if(UpDcNum) UpDcNum--; }
 122          
 123          void sysint()
 124          {
 125   1        intMcu(); 
 126   1        intUsart();
 127   1        #if TIMER2
                Timer2_Init();
                #endif
 130   1        intRun();
 131   1        intBuzz();
 132   1        intErr();
 133   1        intInput();
 134   1        intclk();
 135   1        intMotor();
 136   1        intOut(); 
 137   1        intAtRun();
 138   1        RomTest();
 139   1      }
 140          
 141          
 142          
 143          void iTaskCtr()
 144          {
 145   1      
 146   1        if(iTask < Even)
 147   1          {
 148   2            iTask2= iTask_buf[mPosD][Even];   //¸ù¾ÝÊÂ¼þºÍ×´Ì¬²é±í£¬»ñÈ¡ÈÎÎñ
 149   2            
 150   2            if(iTask2!= MTASK_NA) 
 151   2              {
 152   3                mTask= iTask2;
 153   3                iTask= Even;
 154   3                if(!JY) if(iTask== ITASK_DG_UP || iTask== ITASK_DRAG_UP)  UpCt++;
 155   3              }
 156   2          }
 157   1      }
 158          
 159          
 160          void ViceCtr()
 161          {
 162   1        if(McuId== MACHI_VICE)
 163   1          {
 164   2            switch(ViceRal)
 165   2              {
 166   3                case POS_HOR:
 167   3                case POS_DW:
 168   3                  Event(ITASK_COM_DW);
 169   3                  speak(VICE_STA,mPosD2);
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 4   

 170   3                  break;
 171   3                case POS_UP:
 172   3                case POS_VER:
 173   3                  HDwSta=STA_NA; HDwNum=HDW_ON_TIME;
 174   3                  DgSta=STA_NA; DgNum=DG_OFF_TIME;
 175   3                  Event(ITASK_COM_UP);
 176   3                  speak(VICE_STA,mPosD2);
 177   3                  break;
 178   3                case POS_INT:
 179   3                  speak(VICE_STA,mPosD2);
 180   3                  break;
 181   3                default: break;
 182   3              }
 183   2            ViceRal=0;
 184   2          }
 185   1        if(McuId== MACHI_MASTER)
 186   1          { 
 187   2            if(iTask== ITASK_INT || iTask== ITASK_STR) return;
 188   2            if(!ComNum) ComNum= COM_TIME;
 189   2            else return;
 190   2            switch(mPosD2)
 191   2              {
 192   3                case POS_HOR:
 193   3                case POS_DW:
 194   3                  switch(ViceRal)
 195   3                    {
 196   4                      case POS_HOR:
 197   4                        ViceSta=0;
 198   4                        speak(VICE_STA,POS_INT);
 199   4                        break;
 200   4                      case POS_DW:
 201   4                        if(!ViceSta) ViceSta=VICE_STA_EN;
 202   4                        if(ViceSta==VICE_STA_DGON)        speak(VICE_STA,POS_UP);
 203   4                        else                  speak(VICE_STA,POS_INT);
 204   4                        break;
 205   4                      case POS_VER:
 206   4                        if(!ViceSta) ViceSta=VICE_STA_EN; 
 207   4                        if(mPosD2==POS_DW)            speak(VICE_STA,POS_DW);
 208   4                        if(ViceSta==VICE_STA_DW)        speak(VICE_STA,POS_DW);
 209   4                        else if(ViceSta==VICE_STA_DGOF)     { speak(VICE_STA,POS_DW); ViceSta=0; }
 210   4                        else                  speak(VICE_STA,POS_INT);
 211   4                        break;
 212   4                      case POS_UP:
 213   4                        if(ViceSta!=VICE_STA_DGON)        DgStaClr();
 214   4                        if(!ViceSta)              ViceSta=VICE_STA_EN;
 215   4                        if(mPosD2==POS_DW)            Event(ITASK_COM_UP);
 216   4                        else if(ViceSta==VICE_STA_DGOF)     speak(VICE_STA,POS_DW);
 217   4                        else                  speak(VICE_STA,POS_INT);
 218   4                        break;
 219   4                      default: 
 220   4                        speak(VICE_STA,POS_INT);
 221   4                        break;
 222   4                    }
 223   3                  ViceRal=0;
 224   3                  break;
 225   3                case POS_VER:
 226   3                case POS_UP:
 227   3                  speak(VICE_STA,mPosD2);
 228   3                  break;
 229   3                default: 
 230   3                  speak(VICE_STA,mPosD2);
 231   3                  break;
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 5   

 232   3              }
 233   2          }
 234   1        
 235   1      
 236   1        //***********************·¢ËÍ×´Ì¬´¦Àí***********************//
 237   1        
 238   1      }
 239          
 240          void iTaskControl()     //Íâ²¿ÈÎÎñ´¦Àí
 241          {
 242   1      
 243   1        ViceCtr();    //¸±»ú¿ØÖÆ
 244   1        switch(iTask) //µ±Ç°Ö´ÐÐÈÎÎñ
 245   1          {
 246   2            case ITASK_INT:
 247   2              BmRed();    //²¦Âë²ÎÊý¶ÁÈ¡
 248   2              if(!HUP && !HDW && !HOR) AtNum= 30;
 249   2              else AtNum= 6;
 250   2              iTask=ITASK_STR;
 251   2              break;
 252   2      
 253   2            case ITASK_STR:
 254   2              if(!HUP && !HDW && !HOR && !AtNum) { aLine= 1;iTask= ITASK_NA; }
 255   2              else if(!AtNum) { iTask=ITASK_NA; }
 256   2              break;
 257   2      
 258   2            case ITASK_REACH_H:
 259   2            case ITASK_REACH_V:
 260   2            case ITASK_INER_OK:
 261   2            case ITASK_COER_OK:
 262   2              iTask=ITASK_NA;
 263   2              break;
 264   2              
 265   2      
 266   2            case ITASK_NA:
 267   2            case ITASK_COER_UP:
 268   2            case ITASK_INER_DW:
 269   2              iTaskCtr();
 270   2              break;
 271   2              
 272   2            case ITASK_DG_UP:
 273   2            case ITASK_DRAG_UP:
 274   2            case ITASK_FZ_UP:
 275   2            case ITASK_AUTO_UP:
 276   2            case ITASK_COM_UP:
 277   2            case ITASK_VDO_UP:
 278   2            case ITASK_HAN_UP:
 279   2              iTaskCtr();
 280   2              break;
 281   2              
 282   2            case ITASK_HAN_DW:
 283   2            case ITASK_COM_DW:
 284   2            case ITASK_AUTO_DW:
 285   2            case ITASK_DG_DW:
 286   2              iTaskCtr();
 287   2              break;
 288   2      
 289   2              
 290   2            default: iTask=ITASK_NA; break;   //µç»úÏà¹Ø±äÁ¿³õÊ¼»¯
 291   2          }
 292   1      }
 293          
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 6   

 294          void t0_interrupt(void)  interrupt 1 //using 1
 295          {
 296   1        TF0= 0;
 297   1        TL0 = 0xCD;   //ÉèÖÃ¶¨Ê±³õÖµ
 298   1        TH0 = 0xF8;   //ÉèÖÃ¶¨Ê±³õÖµ
 299   1      
 300   1      
 301   1        T1Ms_clk();
 302   1        mCtrClk();
 303   1        ComClk();
 304   1      //  LED=!LED;
 305   1      }
 306          
 307          
 308          
 309          #if 0 
              //  ÂäÕ¢Ê±·ÖÎª5¸ö½×¶Î£¬·Ö±ðÊÇ
              //  1.Æð²½½×¶Î£¬´¹Ö±Î»µ½Æð²½Î»
              //  2.ÔËÐÐ½×¶Î£¬Æð²½Î»µ½ÖÐ¶Î
              //  3.¼õËÙ½×¶Î£¬ÖÐ¶Îµ½»º³åÎ»
              //  4.»º³å½×¶Î£¬»º³åµ½Æ½ÎÈÎ»
              //  5.ÎÈ¶¨½×¶Î£¬Æ½ÎÈÎ»µ½Ë®Æ½Î»
              //  ´ó¸ÅË¼Â·ÊÇ£¬¸ù¾Ý²âÊÔµÄÊý¾Ý£¬µÃ³öÆð²½½×¶ÎºÍÔËÐÐ½×¶ÎµÄËùÐèÒªµÄ×ªÊýÇø¼ä
              //  È»ºó´ÓÕâ¸öÇø¼ä¿ªÊ¼ÅÐ¶¨£¬¸ù¾Ý½øÈë¶¨Ê±Æ÷µÄ´ÎÊý£¬µÃµ½ÐÂµÄ×ªÊý£¬ÒÔ¼°×ÜµÄÊ±¼ä
              //  Õâ¸öÊ±¼äÔÙ¸ù¾Ý¾­ÑéÖµ£¬ÅÐ¶¨ÊÇ²»ÊÇ³¬³öÎÒÃÇÔ¤ÆÚµÄ×ªÊýÇø¼ä£¬ÈôÊÇ£¬ÔòÌ§Õ¢
              
              //Ô¤ÆÚµÄÂäÕ¢Ê±¼äÎª5Ãë£¬¿ìÓÚ5Ãë£¬ÈÏÎª¾ÍÓÐ·çÏÕ
              
              
              void testTimer2(void)
              { 
                //Ê×ÏÈÅÐ¶ÏÊÇ·ñµ½ÁË¼õËÙ½×¶Î
                //30ÊÇ¼ÙÉèµ½¼õËÙ½×¶Î²âËÙ»·µÄ×ªÊý£¬Êµ¼ÊÐèÒªÈ¥ÊÖ¶¯µÄ¼ÆÁ¿
                if(SpeRinN >= 30) //ÒÑµ½¼õËÙ½×¶Î£¬Ö®ºóÒª¸ù¾Ý²âËÙ»·µÄÈ¦ÊýºÍÊ±¼äÅÐ¶¨ÊÇ·ñÊ§ËÙ
                {
                  if(gRepairMotor.CurrentCounts == 0)
                  {
                    gRepairMotor.InitSpeRin = SpeRinN;//¼ÇÂ¼¿ªÊ¼¼ÆËãÇ°²âËÙ»·µÄÈ¦Êý
                  }
                  
                  gRepairMotor.CurrentCounts++;//½øÈëÖÐ¶ÏµÄ´ÎÊý£¬¸ù¾ÝÖÐ¶ÏµÄ´ÎÊýÅÐ¶¨ËùÓÃµÄÊ±¼ä
                  
                  //ÒòÎªÊÇ10msµÄ¶¨Ê±Æ÷£¬3.8µÄµç»úÃ¿¸öÖÜÆÚÊÇ22.5ms£¬ËùÓÐ½øÐÐÅÐ¶¨Ã¿50msÓÐÁ½´Î
                  //ÕâÀï²âÊÔÊ¹ÓÃ£¬ÏÈ¹Ì¶¨3.8µç»ú£¬releaseÊ±»áÊ¹ÓÃºê¶¨Òå£¬¶¨Òå²»Í¬µÄ¼ÆËã·½Ê½ºÍÅÐ¶¨Ìõ¼þ
                  if((gRepairMotor.CurrentCounts != 0) && (gRepairMotor.CurrentCounts % 5 == 0))
                  {
                    if (gRepairMotor.FlagValue >= 4)
                    {
                      Event(ITASK_DG_UP);//Î£ÏÕ£¬Ì§¸Ë
                    }
                    
                    if(gRepairMotor.LastSpeRin !=0)
                    {
                      //ÕâÀï¸ù¾ÝÊÇ¿ª5Uµç»úºÍ3Uµç»úÅÐ¶¨£¬¿ÕÔØ×î¿ì8È¦£¬ËùÒÔÈ¡6È¦×öÎªÅÐ¶¨Ìõ¼þ
                      if((SpeRinN - gRepairMotor.LastSpeRin) >= 4  /*&&ÕâÀïÓ¦¸Ã¸ù¾ÝµçÑ¹*/)
                      {
                        //Õâ¸öÊ±ºò¾Í±È½ÏÎ£ÏÕÁË
                        gRepairMotor.FlagValue++;
                      }
                    }
              
                    gRepairMotor.LastSpeRin = SpeRinN;
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 7   

                    
                    //´òÓ¡µ±Ç°²âËÙ»·Öµ
                    Uart_Print(3,gRepairMotor.Direction);     
              
                  }
                }
                
              }
              
              //¶¨Ê±Æ÷ÖÐ¶Ï2
              void Timer2_ISR(void) interrupt 5 //¶¨Ê±Æ÷2ÖÐ¶Ï
              {
                TF2=0;
                EXF2 = 0;
                TL2 = (65536 - 9216) / 256;   //ÉèÖÃ¶¨Ê±³õÖµ
                TH2 = (65536 - 9216) % 256;   //ÉèÖÃ¶¨Ê±³õÖµ
              
                testTimer2();  
              }
              #endif 
 376          
 377          
 378          //#define TIMER_FRE  5         //¼ÆËãÖÜÆÚ
 379          //#define BASIC_OFFSET_250MS 4 //Ã¿250ms²âËÙ»·×ªµ½µÄÈ¦Êý
 380          //#define SPRING_PARAM_OFFSET1 2//µ¯»É²ÎÊý
 381          //#define SPRING_PARAM_OFFSET2 3//µ¯»É²ÎÊý
 382          //#define SPRING_PARAM_OFFSET3 4//µ¯»É²ÎÊý
 383          //#define BASIC_SPRING_NUM 46//µ¯»É±ê×¼Öµ
 384          
 385          //#define START_POSITION 50   //´ÓµÚ50´Î½øÈëÖÐ¶Ï¿ªÊ¼¼ÆËã
 386          //#define END_POSITION (START_POSITION+TIMER_FRE*SPRING_CHECK_NUM)  //´ÓµÚ50´Î½øÈëÖÐ¶Ï¿ªÊ¼¼ÆËã
 387          //#define TIMER_FRE  5        //¼ÆËãÖÜÆÚ
 388          //#define THREE_SPRING_LOWER_LIMIT 16 //Èç¹ûÍ³¼Æ×ÜµÄÈ¦Êý²î´óÓÚÕâ¸öÖµ£¬ËµÃ÷ÒÑ¾­²»ÊÇÈý¸ùµ¯»ÉÁË
 389          //#define TWO_SPRINT_LOWER_LIMIT 26 //Èç¹ûÍ³¼Æ×ÜµÄÈ¦Êý²î´óÓÚÕâ¸öÖµ£¬ËµÃ÷ÒÑ¾­²»ÊÇÁ½¸ùµ¯»ÉÁË
 390          //#define BASIC_SPRING_NUM 38//µ¯»É±ê×¼Öµ
 391          //#define BASIC_OFFSET_250MS 4 //Ã¿250ms²âËÙ»·×ªµ½µÄÈ¦Êý
 392          //#define SPRING_CHECK_NUM 6//È¡Ñù´ÎÊý
 393          
 394          #if TIMER2
              
              void motorTimer2(void)
              {
              //    gRepairMotor.CurrentCounts++ ;
              //    //´òÓ¡µ±Ç°²âËÙ»·Öµ
              //    Uart_Print(3,gRepairMotor.Direction);   
              
                  gRepairMotor.CurrentCounts++ ;
                  //´òÓ¡µ±Ç°²âËÙ»·Öµ
                  Uart_Print(3,gRepairMotor.Direction);  
              
              //    if(SpeRinN >= 1 && gRepairMotor.Direction == POS_DW) //²âËÙ»·×ª¶¯²Å¿ªÊ¼½øÀ´
              //    { 
              //        gRepairMotor.CurrentCounts++ ; 
              
              //        if((gRepairMotor.CurrentCounts >= START_POSITION) && (gRepairMotor.CurrentCounts % TIMER_FRE == 
             -0) && gRepairMotor.CurrentCounts <= END_POSITION)//38
              //        {
              //            gRepairMotor.Times++;
              //            
              //            if(SpeRinN >= BASIC_SPRING_NUM + BASIC_OFFSET_250MS*gRepairMotor.Times)
              //            {
              //                gRepairMotor.FlagValue ++;//ÕâÀïÓ¦¸Ã²»»á³öÏÖ£¬Èç¹û³öÏÖ¾ÍÊÇ´óÎÊÌâ
C51 COMPILER V9.00   RUN                                                                   03/20/2019 17:17:59 PAGE 8   

              //            }   
              
              //            gRepairMotor.LastSpeRin = SpeRinN;
              //            //¼ÆËãµ±Ç°¶à×ßÁË¶àÉÙÈ¦
              //            if(gRepairMotor.LastSpeRin > (BASIC_SPRING_NUM+BASIC_OFFSET_250MS*(gRepairMotor.Times-1)))
              //            {                
              //                gRepairMotor.AverageValue += gRepairMotor.LastSpeRin-(BASIC_SPRING_NUM+BASIC_OFFSET_250M
             -S*(gRepairMotor.Times-1));                
              //            }
              
              //            if(gRepairMotor.Times <= 4 && gRepairMotor.AverageValue >= BASIC_OFFSET_250MS*3)
              //            {
              //                Event(ITASK_DG_UP);
              //                err_volu(ERR_SPRI_ERR); 
              //            }
              // 
              //            if (gRepairMotor.FlagValue >= 4 || gRepairMotor.AverageValue >= TWO_SPRINT_LOWER_LIMIT) //²»
             -ÐèÍêÈ«×ßÍêÅÐ¶¨£¬¿ÉÒÔÖ±½ÓÈÏÎªÊÇÓÐÎÊÌâµÄ 
              //            //if (gRepairMotor.FlagValue >= 4 )
              //            {            
              //                Event(ITASK_DG_UP);
              //                err_volu(ERR_SPRI_ERR);
              //                
              //            }
              
              //            if(gRepairMotor.AverageValue >= THREE_SPRING_LOWER_LIMIT)
              //            {
              //                //±¨¾¯£¬Ö»ÓÐÁ½¸ùµ¯»É   
              //                err_volu(ERR_SPRI_LIT);
              //            }
              
              //            //´òÓ¡µ±Ç°²âËÙ»·Öµ
              //        Uart_Print(3,gRepairMotor.Direction);            
              //        }  
              //        
              //    }
              
              }
              
              //¶¨Ê±Æ÷ÖÐ¶Ï2
              void Timer2_ISR(void) interrupt 5 //¶¨Ê±Æ÷2ÖÐ¶Ï
              {
                TF2=0;
                EXF2 = 0;
                motorTimer2(); 
              }
              
              #endif
 463          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    768    ----
   CONSTANT SIZE    =    126    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
