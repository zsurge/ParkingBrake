C51 COMPILER V9.00   ROMTEST                                                               03/20/2019 17:17:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ROMTEST
OBJECT MODULE PLACED IN ..\HEX\romtest.obj
COMPILER INVOKED BY: c:\Keil\C51\BIN\C51.EXE ..\SCR\romtest.c BROWSE INCDIR(..\INC) DEBUG OBJECTEXTEND PRINT(.\romtest.l
                    -st) TABS(2) OBJECT(..\HEX\romtest.obj)

line level    source

   1          /****************************************************************************
   2          * File:     romtest.c                         *
   3          * Created:    2015-02-13                          *
   4          * Last Change:                                *
   5          * Author:   chen zhi peng                         *
   6          * Description:                                *
   7          ****************************************************************************/
   8          #include "ROMTEST.h"
   9          
  10          
  11          
  12          
  13          //********************************************************************************************************
             -****//
  14          ////存储器测试
  15          //********************************************************************************************************
             -****//
  16          void RomTest()
  17          {    
  18   1        u8 t=0,i=0; u8 xdata buff[8];
  19   1        WDT_CONTR=DISABLE;    //内部看门狗关闭
  20   1        err=ERR_EEPROM_WRITE;
  21   1        EEPROM_read_n(FIRST_SECTOR,&buff,8);
  22   1        for(t=0;t<8;t++) {if(buff[t]==eight) i++;}  //存储器识别码
  23   1        if(i==8)err=ERR_INT;    
  24   1        if(err==ERR_EEPROM_WRITE)//系统初始化
  25   1          {
  26   2        //********擦&写&读3次测试X个扇区**********//
  27   2            for(t=0;t<1;t++)
  28   2              { 
  29   3                SectotE(FIRST_SECTOR,0x200,2);//删除x扇区
  30   3                delay(10);
  31   3                SectotWT(FIRST_SECTOR,0xaa,2);  //x个扇区里全写满数据0xAA=10101010
  32   3                delay(10);
  33   3                if(SectotRT(FIRST_SECTOR,0xaa,2)) { BUZZ=BUZZ_EN;  } //读x个扇区并判断数据是否错误
  34   3                delay(10);
  35   3                SectotE(FIRST_SECTOR,0x200,2);//删除x扇区
  36   3                delay(10);
  37   3                SectotWT(FIRST_SECTOR,0x55,2);//x个扇区里全写满数据0x55=01010101
  38   3                delay(10);
  39   3                if(SectotRT(FIRST_SECTOR,0x55,2)) { BUZZ=BUZZ_EN;  } //读x个扇区并判断数据是否错误
  40   3                delay(10);
  41   3              }
  42   2        //********测试完成，1扇区写入初始化识别数-8个识别码,用作识别是否已经初始化配置**********//
  43   2            if(BUZZ)
  44   2              {
  45   3                EEPROM_SectorErase(FIRST_SECTOR);
  46   3                for(t=0;t<8;t++) buff[t]=eight;
  47   3                EEPROM_write_n(FIRST_SECTOR,&buff,8);
  48   3              }
  49   2            else 
  50   2              {
  51   3                BUZZ=BUZZ_CL;
  52   3                err=ERR_EEPROM_WRITE1;
C51 COMPILER V9.00   ROMTEST                                                               03/20/2019 17:17:59 PAGE 2   

  53   3              }
  54   2          }
  55   1      
  56   1      }
  57          
  58          
  59          
  60          
  61          
  62          //********************************************************************************************************
             -****
  63          ////SectotE扇区删除
  64          //入口变量 dx:扇区起始地址
  65          //       hf:扇区首地址间隔
  66          //       tt:删除扇区数量
  67          //         
  68          //********************************************************************************************************
             -****
  69          void SectotE(u16 dx, u16 hf, u8 tt)
  70          {
  71   1      
  72   1      
  73   1        u8 k;
  74   1        for(k=0;k<tt;k++)
  75   1          { 
  76   2            LED=1;
  77   2            EEPROM_SectorErase(dx);
  78   2            delay(10);
  79   2            dx+=hf;
  80   2          }
  81   1      }
  82          
  83          //********************************************************************************************************
             -****
  84          ////SectotWT扇区写入测试
  85          //入口变量  dx:扇区起始地址
  86          //      nu:要写的数据
  87          //        tt:写操作扇区数量
  88          //********************************************************************************************************
             -****
  89          void SectotWT(u16 dx, u8 nu, u8 tt)
  90          {
  91   1      
  92   1      
  93   1        u8 k,i; u8 xdata buff[8];
  94   1        for(k=0;k<8;k++) buff[k]=nu;
  95   1        for(k=0;k<tt;k++)
  96   1          {
  97   2            for(i=0;i<64;i++)//一个扇区分64次写入，一次写8个字节
  98   2              {
  99   3                EEPROM_write_n(dx,&buff,8);
 100   3                dx+=8;
 101   3                delay(10);
 102   3              }
 103   2            LED=!LED;
 104   2            
 105   2            delay(30);
 106   2          }
 107   1        
 108   1      }
 109                    
 110          
C51 COMPILER V9.00   ROMTEST                                                               03/20/2019 17:17:59 PAGE 3   

 111          //********************************************************************************************************
             -****
 112          ////SectotRT扇区读出测试
 113          //入口变量  dx:扇区起始地址
 114          //      nu:要比较的数据
 115          //        tt:读操作扇区数量
 116          //********************************************************************************************************
             -****
 117          bit SectotRT(u16 dx, u8 nu, u8 tt)
 118          {
 119   1      
 120   1        u8 k,u,i;   u8 xdata buff[8];    u16 cnum=0;
 121   1      
 122   1        for(k=0;k<tt;k++)
 123   1          {
 124   2            for(i=0;i<64;i++) 
 125   2              {
 126   3                EEPROM_read_n(dx,&buff,8);
 127   3                dx+=8;
 128   3                for(u=0;u<8;u++)
 129   3                  {
 130   4                    if(buff[u]==nu)
 131   4                    cnum++;
 132   4                  }
 133   3                LED=!LED;
 134   3                delay(10);
 135   3              }
 136   2            delay(30);
 137   2          }
 138   1        if(cnum<(512*tt-1)) return 1;
 139   1        else return 0;
 140   1        return 0;
 141   1      
 142   1      }
 143          
 144          
 145          
 146          
 147          
 148          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    557    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
